// Imports

import RelateURL from 'relateurl';
import { stableStringify, identity, identityAsync, replaceAsync } from './utils.js';
import { RE_TRAILING_SEMICOLON } from './constants.js';
import { canCollapseWhitespace, canTrimWhitespace } from './whitespace.js';
import { wrapCSS, unwrapCSS } from './content.js';
import { getSVGMinifierOptions } from './svg.js';
import { getPreset, getPresetNames } from '../presets.js';

// Helper functions

function shouldMinifyInnerHTML(options) {
  return Boolean(
    options.collapseWhitespace ||
    options.removeComments ||
    options.removeOptionalTags ||
    options.minifyJS !== identity ||
    options.minifyCSS !== identityAsync ||
    options.minifyURLs !== identity ||
    options.minifySVG
  );
}

// Main options processor

/**
 * @param {Partial<MinifierOptions>} inputOptions - User-provided options
 * @param {Object} deps - Dependencies from htmlminifier.js
 * @param {Function} deps.getLightningCSS - Function to lazily load Lightning CSS
 * @param {Function} deps.getTerser - Function to lazily load Terser
 * @param {Function} deps.getSwc - Function to lazily load @swc/core
 * @param {LRU} deps.cssMinifyCache - CSS minification cache
 * @param {LRU} deps.jsMinifyCache - JS minification cache
 * @param {LRU} deps.urlMinifyCache - URL minification cache
 * @returns {MinifierOptions} Normalized options with defaults applied
 */
const processOptions = (inputOptions, { getLightningCSS, getTerser, getSwc, cssMinifyCache, jsMinifyCache, urlMinifyCache } = {}) => {
  const options = {
    name: function (name) {
      return name.toLowerCase();
    },
    canCollapseWhitespace,
    canTrimWhitespace,
    continueOnMinifyError: true,
    html5: true,
    ignoreCustomComments: [
      /^!/,
      /^\s*#/
    ],
    ignoreCustomFragments: [
      /<%[\s\S]*?%>/,
      /<\?[\s\S]*?\?>/
    ],
    includeAutoGeneratedTags: true,
    log: identity,
    minifyCSS: identityAsync,
    minifyJS: identity,
    minifyURLs: identity,
    minifySVG: null
  };

  // Helper to convert string patterns to RegExp (for JSON config support)
  const parseRegExp = (value) => {
    if (typeof value === 'string') {
      return new RegExp(value.replace(/^\/(.*)\/$/, '$1'));
    }
    return value; // Already a RegExp or another type
  };

  const parseRegExpArray = (arr) => {
    return Array.isArray(arr) ? arr.map(parseRegExp) : arr;
  };

  // Helper for nested arrays (e.g., `customAttrSurround: [[start, end], …]`)
  const parseNestedRegExpArray = (arr) => {
    if (!Array.isArray(arr)) return arr;
    return arr.map(item => {
      // If item is an array (a pair), recursively convert each element
      if (Array.isArray(item)) {
        return item.map(parseRegExp);
      }
      // Otherwise, convert single item
      return parseRegExp(item);
    });
  };

  // Apply preset first if specified (so user options can override preset values)
  if (inputOptions.preset) {
    const preset = getPreset(inputOptions.preset);
    if (preset) {
      Object.assign(options, preset);
    } else {
      const available = getPresetNames().join(', ');
      console.warn(`html-minifier-next: Unknown preset "${inputOptions.preset}". Available presets: ${available}`);
    }
  }

  Object.keys(inputOptions).forEach(function (key) {
    const option = inputOptions[key];

    // Skip preset key—it’s already been processed
    if (key === 'preset') {
      return;
    }

    if (key === 'caseSensitive') {
      if (option) {
        options.name = identity;
      }
    } else if (key === 'log') {
      if (typeof option === 'function') {
        options.log = option;
      }
    } else if (key === 'minifyCSS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      const lightningCssOptions = typeof option === 'object' ? option : {};

      options.minifyCSS = async function (text, type) {
        // Fast path: Nothing to minify
        if (!text || !text.trim()) {
          return text;
        }

        // Optimization: Only process URLs if minification is enabled (not identity function)
        // This avoids expensive `replaceAsync` when URL minification is disabled
        if (options.minifyURLs !== identity) {
          text = await replaceAsync(
            text,
            /(url\s*\(\s*)(?:"([^"]*)"|'([^']*)'|([^\s)]+))(\s*\))/ig,
            async function (match, prefix, dq, sq, unq, suffix) {
              const quote = dq != null ? '"' : (sq != null ? "'" : '');
              const url = dq ?? sq ?? unq ?? '';
              try {
                const out = await options.minifyURLs(url);
                return prefix + quote + (typeof out === 'string' ? out : url) + quote + suffix;
              } catch (err) {
                if (!options.continueOnMinifyError) {
                  throw err;
                }
                options.log && options.log(err);
                return match;
              }
            }
          );
        }

        // Cache key: Wrapped content, type, options signature
        const inputCSS = wrapCSS(text, type);
        const cssSig = stableStringify({ type, opts: lightningCssOptions, cont: !!options.continueOnMinifyError });
        // For large inputs, use length and content fingerprint (first/last 50 chars) to prevent collisions
        const cssKey = inputCSS.length > 2048
          ? (inputCSS.length + '|' + inputCSS.slice(0, 50) + inputCSS.slice(-50) + '|' + type + '|' + cssSig)
          : (inputCSS + '|' + type + '|' + cssSig);

        try {
          const cached = cssMinifyCache.get(cssKey);
          if (cached) {
            // Support both resolved values and in-flight promises
            return await cached;
          }

          // In-flight promise caching: Prevent duplicate concurrent minifications
          // of the same CSS content (same pattern as JS minification)
          const inFlight = (async () => {
            const transformCSS = await getLightningCSS();
            // Note: `Buffer.from()` is required—Lightning CSS API expects Uint8Array
            const result = transformCSS({
              filename: 'input.css',
              code: Buffer.from(inputCSS),
              minify: true,
              errorRecovery: !!options.continueOnMinifyError,
              ...lightningCssOptions
            });

            const outputCSS = unwrapCSS(result.code.toString(), type);

            // If Lightning CSS removed significant content that looks like template syntax or UIDs, return original
            // This preserves:
            // 1. Template code like `<?php ?>`, `<%= ?>`, `{{ }}`, etc. (contain `<` or `>` but not `CDATA`)
            // 2. UIDs representing custom fragments (only lowercase letters and digits, no spaces)
            // CDATA sections, HTML entities, and other invalid CSS are allowed to be removed
            const isCDATA = text.includes('<![CDATA[');
            const uidPattern = /[a-z0-9]{10,}/; // UIDs are long alphanumeric strings
            const hasUID = uidPattern.test(text) && !isCDATA; // Exclude CDATA from UID detection
            const looksLikeTemplate = (text.includes('<') || text.includes('>')) && !isCDATA;

            // Preserve if output is empty and input had template syntax or UIDs
            // This catches cases where Lightning CSS removed content that should be preserved
            return (text.trim() && !outputCSS.trim() && (looksLikeTemplate || hasUID)) ? text : outputCSS;
          })();

          cssMinifyCache.set(cssKey, inFlight);
          const resolved = await inFlight;
          cssMinifyCache.set(cssKey, resolved);
          return resolved;
        } catch (err) {
          cssMinifyCache.delete(cssKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyJS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      // Parse configuration
      const config = typeof option === 'object' ? option : {};
      const engine = (config.engine || 'terser').toLowerCase();

      // Validate engine
      const supportedEngines = ['terser', 'swc'];
      if (!supportedEngines.includes(engine)) {
        throw new Error(`Unsupported JS minifier engine: “${engine}”. Supported engines: ${supportedEngines.join(', ')}`);
      }

      // Extract engine-specific options (excluding `engine` field itself)
      const engineOptions = { ...config };
      delete engineOptions.engine;

      // Terser options (needed for inline JS and when engine is `terser`)
      const terserOptions = engine === 'terser' ? engineOptions : {};
      terserOptions.parse = {
        ...terserOptions.parse,
        bare_returns: false
      };

      // SWC options (when engine is `swc`)
      const swcOptions = engine === 'swc' ? engineOptions : {};

      // Pre-compute option signatures once for performance (avoid repeated stringification)
      const terserSig = stableStringify({
        ...terserOptions,
        cont: !!options.continueOnMinifyError
      });
      const swcSig = stableStringify({
        ...swcOptions,
        cont: !!options.continueOnMinifyError
      });

      options.minifyJS = async function (text, inline) {
        const start = text.match(/^\s*<!--.*/);
        const code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;

        // Fast path: Avoid invoking minifier for empty/whitespace-only content
        if (!code || !code.trim()) {
          return '';
        }

        // Hybrid strategy: Always use Terser for inline JS (needs bare returns support)
        // Use user’s chosen engine for script blocks
        const useEngine = inline ? 'terser' : engine;

        let jsKey;
        try {
          // Select pre-computed signature based on engine
          const optsSig = useEngine === 'terser' ? terserSig : swcSig;

          // For large inputs, use length and content fingerprint to prevent collisions
          jsKey = (code.length > 2048 ? (code.length + '|' + code.slice(0, 50) + code.slice(-50) + '|') : (code + '|'))
            + (inline ? '1' : '0') + '|' + useEngine + '|' + optsSig;

          const cached = jsMinifyCache.get(jsKey);
          if (cached) {
            return await cached;
          }

          const inFlight = (async () => {
            // Dispatch to appropriate minifier
            if (useEngine === 'terser') {
              // Create a copy to avoid mutating shared `terserOptions` (race condition)
              const terserCallOptions = {
                ...terserOptions,
                parse: {
                  ...terserOptions.parse,
                  bare_returns: inline
                }
              };
              const terser = await getTerser();
              const result = await terser(code, terserCallOptions);
              return result.code.replace(RE_TRAILING_SEMICOLON, '');
            } else if (useEngine === 'swc') {
              const swc = await getSwc();
              // `swc.minify()` takes compress and mangle directly as options
              const result = await swc.minify(code, {
                compress: true,
                mangle: true,
                ...swcOptions, // User options override defaults
              });
              return result.code.replace(RE_TRAILING_SEMICOLON, '');
            }
            throw new Error(`Unknown JS minifier engine: ${useEngine}`);
          })();

          jsMinifyCache.set(jsKey, inFlight);
          const resolved = await inFlight;
          jsMinifyCache.set(jsKey, resolved);
          return resolved;
        } catch (err) {
          if (jsKey) jsMinifyCache.delete(jsKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyURLs' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      let relateUrlOptions = option;

      if (typeof option === 'string') {
        relateUrlOptions = { site: option };
      } else if (typeof option !== 'object') {
        relateUrlOptions = {};
      }

      // Cache relateurl instance for reuse (expensive to create)
      const relateUrlInstance = new RelateURL(relateUrlOptions.site || '', relateUrlOptions);

      // Create instance-specific cache (results depend on site configuration)
      const instanceCache = urlMinifyCache ? new (urlMinifyCache.constructor)(500) : null;

      options.minifyURLs = function (text) {
        // Fast-path: Skip if text doesn’t look like a URL that needs processing
        // Only process if contains URL-like characters (`/`, `:`, `#`, `?`) or spaces that need encoding
        if (!/[/:?#\s]/.test(text)) {
          return text;
        }

        // Check instance-specific cache
        if (instanceCache) {
          const cached = instanceCache.get(text);
          if (cached !== undefined) {
            return cached;
          }
        }

        try {
          const result = relateUrlInstance.relate(text);
          // Cache successful results
          if (instanceCache) {
            instanceCache.set(text, result);
          }
          return result;
        } catch (err) {
          // Don’t cache errors
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifySVG') {
      // Process SVG minification options
      // Unlike `minifyCSS`/`minifyJS`, this is a simple options object, not a function
      // The actual minification is applied inline during attribute processing
      options.minifySVG = getSVGMinifierOptions(option);
    } else if (key === 'customAttrCollapse') {
      // Single regex pattern
      options[key] = parseRegExp(option);
    } else if (key === 'customAttrSurround') {
      // Nested array of RegExp pairs: `[[openRegExp, closeRegExp], …]`
      options[key] = parseNestedRegExpArray(option);
    } else if (['customAttrAssign', 'customEventAttributes', 'ignoreCustomComments', 'ignoreCustomFragments'].includes(key)) {
      // Array of regex patterns
      options[key] = parseRegExpArray(option);
    } else {
      options[key] = option;
    }
  });
  return options;
};

// Exports

export {
  shouldMinifyInnerHTML,
  processOptions
};