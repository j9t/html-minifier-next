// Imports

import RelateURL from 'relateurl';
import { stableStringify, identity, identityAsync, replaceAsync } from './utils.js';
import { RE_TRAILING_SEMICOLON } from './constants.js';
import { canCollapseWhitespace, canTrimWhitespace } from './whitespace.js';
import { wrapCSS, unwrapCSS } from './content.js';

// Helper functions

function shouldMinifyInnerHTML(options) {
  return Boolean(
    options.collapseWhitespace ||
    options.removeComments ||
    options.removeOptionalTags ||
    options.minifyJS !== identity ||
    options.minifyCSS !== identityAsync ||
    options.minifyURLs !== identity
  );
}

// Main options processor

/**
 * @param {Partial<MinifierOptions>} inputOptions - User-provided options
 * @param {Object} deps - Dependencies from htmlminifier.js
 * @param {Function} deps.getLightningCSS - Function to lazily load lightningcss
 * @param {Function} deps.getTerser - Function to lazily load terser
 * @param {Function} deps.getSwc - Function to lazily load @swc/core
 * @param {LRU} deps.cssMinifyCache - CSS minification cache
 * @param {LRU} deps.jsMinifyCache - JS minification cache
 * @returns {MinifierOptions} Normalized options with defaults applied
 */
const processOptions = (inputOptions, { getLightningCSS, getTerser, getSwc, cssMinifyCache, jsMinifyCache } = {}) => {
  const options = {
    name: function (name) {
      return name.toLowerCase();
    },
    canCollapseWhitespace,
    canTrimWhitespace,
    continueOnMinifyError: true,
    html5: true,
    ignoreCustomComments: [
      /^!/,
      /^\s*#/
    ],
    ignoreCustomFragments: [
      /<%[\s\S]*?%>/,
      /<\?[\s\S]*?\?>/
    ],
    includeAutoGeneratedTags: true,
    log: identity,
    minifyCSS: identityAsync,
    minifyJS: identity,
    minifyURLs: identity
  };

  Object.keys(inputOptions).forEach(function (key) {
    const option = inputOptions[key];

    if (key === 'caseSensitive') {
      if (option) {
        options.name = identity;
      }
    } else if (key === 'log') {
      if (typeof option === 'function') {
        options.log = option;
      }
    } else if (key === 'minifyCSS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      const lightningCssOptions = typeof option === 'object' ? option : {};

      options.minifyCSS = async function (text, type) {
        // Fast path: Nothing to minify
        if (!text || !text.trim()) {
          return text;
        }
        text = await replaceAsync(
          text,
          /(url\s*\(\s*)(?:"([^"]*)"|'([^']*)'|([^\s)]+))(\s*\))/ig,
          async function (match, prefix, dq, sq, unq, suffix) {
            const quote = dq != null ? '"' : (sq != null ? "'" : '');
            const url = dq ?? sq ?? unq ?? '';
            try {
              const out = await options.minifyURLs(url);
              return prefix + quote + (typeof out === 'string' ? out : url) + quote + suffix;
            } catch (err) {
              if (!options.continueOnMinifyError) {
                throw err;
              }
              options.log && options.log(err);
              return match;
            }
          }
        );
        // Cache key: Wrapped content, type, options signature
        const inputCSS = wrapCSS(text, type);
        const cssSig = stableStringify({ type, opts: lightningCssOptions, cont: !!options.continueOnMinifyError });
        // For large inputs, use length and content fingerprint (first/last 50 chars) to prevent collisions
        const cssKey = inputCSS.length > 2048
          ? (inputCSS.length + '|' + inputCSS.slice(0, 50) + inputCSS.slice(-50) + '|' + type + '|' + cssSig)
          : (inputCSS + '|' + type + '|' + cssSig);

        try {
          const cached = cssMinifyCache.get(cssKey);
          if (cached) {
            return cached;
          }

          const transformCSS = await getLightningCSS();
          const result = transformCSS({
            filename: 'input.css',
            code: Buffer.from(inputCSS),
            minify: true,
            errorRecovery: !!options.continueOnMinifyError,
            ...lightningCssOptions
          });

          const outputCSS = unwrapCSS(result.code.toString(), type);

          // If Lightning CSS removed significant content that looks like template syntax or UIDs, return original
          // This preserves:
          // 1. Template code like `<?php ?>`, `<%= %>`, `{{ }}`, etc. (contain `<` or `>` but not `CDATA`)
          // 2. UIDs representing custom fragments (only lowercase letters and digits, no spaces)
          // CDATA sections, HTML entities, and other invalid CSS are allowed to be removed
          const isCDATA = text.includes('<![CDATA[');
          const uidPattern = /[a-z0-9]{10,}/; // UIDs are long alphanumeric strings
          const hasUID = uidPattern.test(text) && !isCDATA; // Exclude CDATA from UID detection
          const looksLikeTemplate = (text.includes('<') || text.includes('>')) && !isCDATA;

          // Preserve if output is empty and input had template syntax or UIDs
          // This catches cases where Lightning CSS removed content that should be preserved
          const finalOutput = (text.trim() && !outputCSS.trim() && (looksLikeTemplate || hasUID)) ? text : outputCSS;

          cssMinifyCache.set(cssKey, finalOutput);
          return finalOutput;
        } catch (err) {
          cssMinifyCache.delete(cssKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyJS' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      // Parse configuration
      const config = typeof option === 'object' ? option : {};
      const engine = (config.engine || 'terser').toLowerCase();

      // Validate engine
      const supportedEngines = ['terser', 'swc'];
      if (!supportedEngines.includes(engine)) {
        throw new Error(`Unsupported JS minifier engine: "${engine}". Supported engines: ${supportedEngines.join(', ')}`);
      }

      // Extract engine-specific options (excluding `engine` field itself)
      const engineOptions = { ...config };
      delete engineOptions.engine;

      // Terser options (needed for inline JS and when engine is `terser`)
      const terserOptions = engine === 'terser' ? engineOptions : {};
      terserOptions.parse = {
        ...terserOptions.parse,
        bare_returns: false
      };

      // SWC options (when engine is `swc`)
      const swcOptions = engine === 'swc' ? engineOptions : {};

      options.minifyJS = async function (text, inline) {
        const start = text.match(/^\s*<!--.*/);
        const code = start ? text.slice(start[0].length).replace(/\n\s*-->\s*$/, '') : text;

        // Fast path: Avoid invoking minifier for empty/whitespace-only content
        if (!code || !code.trim()) {
          return '';
        }

        // Hybrid strategy: Always use Terser for inline JS (needs bare returns support)
        // Use user’s chosen engine for script blocks
        const useEngine = inline ? 'terser' : engine;

        let jsKey;
        try {
          // Build cache key including engine
          const optsSig = useEngine === 'terser'
            ? stableStringify({
              compress: terserOptions.compress,
              mangle: terserOptions.mangle,
              ecma: terserOptions.ecma,
              toplevel: terserOptions.toplevel,
              module: terserOptions.module,
              keep_fnames: terserOptions.keep_fnames,
              format: terserOptions.format,
              cont: !!options.continueOnMinifyError,
            })
            : stableStringify({
              compress: swcOptions.compress,
              mangle: swcOptions.mangle,
              cont: !!options.continueOnMinifyError,
            });

          // For large inputs, use length and content fingerprint to prevent collisions
          jsKey = (code.length > 2048 ? (code.length + '|' + code.slice(0, 50) + code.slice(-50) + '|') : (code + '|'))
            + (inline ? '1' : '0') + '|' + useEngine + '|' + optsSig;

          const cached = jsMinifyCache.get(jsKey);
          if (cached) {
            return await cached;
          }

          const inFlight = (async () => {
            // Dispatch to appropriate minifier
            if (useEngine === 'terser') {
              terserOptions.parse.bare_returns = inline;
              const terser = await getTerser();
              const result = await terser(code, terserOptions);
              return result.code.replace(RE_TRAILING_SEMICOLON, '');
            } else if (useEngine === 'swc') {
              const swc = await getSwc();
              // `swc.minify()` takes compress and mangle directly as options
              const result = await swc.minify(code, {
                compress: true,
                mangle: true,
                ...swcOptions, // User options override defaults
              });
              return result.code;
            }
            throw new Error(`Unknown JS minifier engine: ${useEngine}`);
          })();

          jsMinifyCache.set(jsKey, inFlight);
          const resolved = await inFlight;
          jsMinifyCache.set(jsKey, resolved);
          return resolved;
        } catch (err) {
          if (jsKey) jsMinifyCache.delete(jsKey);
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else if (key === 'minifyURLs' && typeof option !== 'function') {
      if (!option) {
        return;
      }

      let relateUrlOptions = option;

      if (typeof option === 'string') {
        relateUrlOptions = { site: option };
      } else if (typeof option !== 'object') {
        relateUrlOptions = {};
      }

      // Cache RelateURL instance for reuse (expensive to create)
      const relateUrlInstance = new RelateURL(relateUrlOptions.site || '', relateUrlOptions);

      options.minifyURLs = function (text) {
        // Fast-path: Skip if text doesn’t look like a URL that needs processing
        // Only process if contains URL-like characters (`/`, `:`, `#`, `?`) or spaces that need encoding
        if (!/[/:?#\s]/.test(text)) {
          return text;
        }

        try {
          return relateUrlInstance.relate(text);
        } catch (err) {
          if (!options.continueOnMinifyError) {
            throw err;
          }
          options.log && options.log(err);
          return text;
        }
      };
    } else {
      options[key] = option;
    }
  });
  return options;
};

// Exports

export {
  shouldMinifyInnerHTML,
  processOptions
};