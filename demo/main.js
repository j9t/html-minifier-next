import HTMLMinifier, { getPreset } from '../dist/htmlminifier.esm.bundle.js';
import pkg from '../package.json' with { type: 'json' };

const defaultOptions = [
  {
    id: 'caseSensitive',
    type: 'checkbox',
    label: 'Case-sensitive',
    helpText: 'Treat attributes in case-sensitive manner (useful for custom HTML elements)'
  },
  {
    id: 'collapseAttributeWhitespace',
    type: 'checkbox',
    label: 'Collapse attribute whitespace',
    helpText: 'Trim and collapse whitespace characters within attribute values'
  },
  {
    id: 'collapseBooleanAttributes',
    type: 'checkbox',
    label: 'Collapse boolean attributes',
    helpText: 'Omit attribute values from boolean attributes',
    checked: true
  },
  {
    id: 'collapseInlineTagWhitespace',
    type: 'checkbox',
    label: 'Collapse inline tag whitespace',
    helpText: `Donâ€™t leave any spaces between <code>display: inline;</code> elements when collapsingâ€”use with <code>collapseWhitespace</code>`,
    unsafe: true
  },
  {
    id: 'collapseWhitespace',
    type: 'checkbox',
    label: 'Collapse whitespace',
    helpText: 'Collapse whitespace that contributes to text nodes in a document tree',
    checked: true
  },
  {
    id: 'conservativeCollapse',
    type: 'checkbox',
    label: 'Conservative collapse',
    helpText: `Always collapse to one space (never remove it entirely)â€”use with <code>collapseWhitespace</code>`
  },
  {
    id: 'decodeEntities',
    type: 'checkbox',
    label: 'Decode entity characters',
    helpText: 'Use direct Unicode characters whenever possible',
    checked: true
  },
  {
    id: 'html5',
    type: 'checkbox',
    label: 'HTML',
    helpText: 'Parse input according to the HTML specification',
    checked: true
  },
  {
    id: 'ignoreCustomFragments',
    type: 'text',
    label: 'Ignore custom fragments',
    helpText: 'Space-separated regex patterns for template syntax to ignoreâ€”<em>use bounded quantifiers</em> like <code>{0,1000}</code> to prevent performance issues (examples: <code>\\{%[\\s\\S]{0,1000}?%\\}</code> for Jinja/Django, <code>\\{\\{[\\s\\S]{0,500}?\\}\\}</code> for Handlebars/Vue)',
    value: ''
  },
  {
    id: 'includeAutoGeneratedTags',
    type: 'checkbox',
    label: 'Include auto-generated tags',
    helpText: 'Insert elements generated by HTML parser'
  },
  {
    id: 'keepClosingSlash',
    type: 'checkbox',
    label: 'Keep closing slash',
    helpText: 'Keep the trailing slash on void elements'
  },
  {
    id: 'maxLineLength',
    type: 'number',
    label: 'Max line length',
    helpText: 'Specify a maximum line length; compressed output will be split by newlines at valid HTML split-points'
  },
  {
    id: 'minifyCSS',
    type: 'checkbox',
    label: 'Minify CSS',
    helpText: 'Minify CSS in <code>style</code> elements and <code>style</code> attributes (disabled in web versionâ€”Lightning CSS requires Node.js)',
    checked: false,
    disabled: true
  },
  {
    id: 'minifyJS',
    type: 'checkbox',
    label: 'Minify JavaScript',
    helpText: 'Minify JavaScript in <code>script</code> elements and event attributes (uses Terser)'
  },
  {
    id: 'minifySVG',
    type: 'checkbox',
    label: 'Minify SVG',
    helpText: 'Minify SVG elements and attributes (numeric precision, default attributes, colors)'
  },
  {
    id: 'minifyURLs',
    type: 'checkbox',
    label: 'Minify URLs',
    helpText: 'Minify URLs in various attributes (uses relateurl)'
  },
  {
    id: 'noNewlinesBeforeTagClose',
    type: 'checkbox',
    label: 'No newline before tag close',
    helpText: 'Never add a newline before a tag that closes an element'
  },
  {
    id: 'partialMarkup',
    type: 'checkbox',
    label: 'Partial markup',
    helpText: 'Treat input as a partial HTML fragment, preserving stray end tags and unclosed tags'
  },
  {
    id: 'preserveLineBreaks',
    type: 'checkbox',
    label: 'Preserve line breaks',
    helpText: `Always collapse to one line break (never remove it entirely) when whitespace between tags includes a line breakâ€”use with <code>collapseWhitespace</code>`
  },
  {
    id: 'preventAttributesEscaping',
    type: 'checkbox',
    label: 'Prevent attributes escaping',
    helpText: 'Prevents the escaping of the values of attributes',
    unsafe: true
  },
  {
    id: 'processConditionalComments',
    type: 'checkbox',
    label: 'Process conditional comments',
    helpText: 'Process contents of conditional comments through minifier'
  },
  {
    id: 'processScripts',
    type: 'text',
    label: 'Process scripts',
    helpText: 'Array of strings corresponding to types of <code>script</code> elements to process through minifier (e.g., <code>text/ng-template</code>, <code>text/x-handlebars-template</code>, etc.)',
    value: 'text/html'
  },
  {
    id: 'quoteCharacter',
    type: 'text',
    label: 'Quote character',
    helpText: 'Type of quote to use for attribute values (<code>\'</code> or <code>"</code>)',
    value: ''
  },
  {
    id: 'removeAttributeQuotes',
    type: 'checkbox',
    label: 'Remove attribute quotes',
    helpText: 'Remove quotes around attributes when possible'
  },
  {
    id: 'removeComments',
    type: 'checkbox',
    label: 'Remove comments',
    helpText: 'Strip HTML comments',
    checked: true
  },
  {
    id: 'removeEmptyAttributes',
    type: 'checkbox',
    label: 'Remove empty attributes',
    helpText: 'Remove all attributes with whitespace-only values'
  },
  {
    id: 'removeEmptyElements',
    type: 'checkbox',
    label: 'Remove empty elements',
    helpText: 'Remove all elements with empty contents',
    unsafe: true
  },
  {
    id: 'removeEmptyElementsExcept',
    type: 'text',
    label: 'Remove empty elements except',
    helpText: 'List of elements to preserve when `removeEmptyElements` is enabled (e.g., <code>td, &lt;span aria-hidden=\'true\'&gt;</code>)',
    value: ''
  },
  {
    id: 'removeOptionalTags',
    type: 'checkbox',
    label: 'Remove optional tags',
    helpText: 'Remove optional tags'
  },
  {
    id: 'removeRedundantAttributes',
    type: 'checkbox',
    label: 'Remove redundant attributes',
    helpText: 'Remove attributes when value matches default'
  },
  {
    id: 'removeScriptTypeAttributes',
    type: 'checkbox',
    label: 'Remove script type attributes',
    helpText: `Remove <code>type="text/javascript"</code> from <code>script</code> elements; other <code>type</code> attribute values are left intact`,
    checked: true
  },
  {
    id: 'removeStyleLinkTypeAttributes',
    type: 'checkbox',
    label: 'Remove style link type attributes',
    helpText: `Remove <code>type="text/css"</code> from <code>style</code> and <code>link</code> elements; other <code>type</code> attribute values are left intact`,
    checked: true
  },
  {
    id: 'removeTagWhitespace',
    type: 'checkbox',
    label: 'Remove tag whitespace',
    helpText: `Remove space between attributes whenever possible; <em>note that this will result in invalid HTML</em>`,
    unsafe: true
  },
  {
    id: 'sortAttributes',
    type: 'checkbox',
    label: 'Sort attributes',
    helpText: 'Sort attributes by frequency',
    unsafe: true
  },
  {
    id: 'sortClassName',
    type: 'checkbox',
    label: 'Sort class name',
    helpText: 'Sort style classes by frequency',
    unsafe: true
  },
  {
    id: 'trimCustomFragments',
    type: 'checkbox',
    label: 'Trim whitespace around custom fragments',
    helpText: 'Trim whitespace around custom fragments (PHP, JSP/ASP tags)'
  },
  {
    id: 'useShortDoctype',
    type: 'checkbox',
    label: 'Use short doctype',
    helpText: 'Replaces the doctype with the short (HTML) doctype',
    checked: true
  }
];

const sillyClone = (o) => JSON.parse(JSON.stringify(o));

const getOptions = (options) => {
  const minifierOptions = {};

  options.forEach((option) => {
    let value = null;

    if (option.type === 'checkbox') {
      value = Boolean(option.checked);
    } else if (option.type === 'number') {
      const n = Number.parseInt(String(option.value), 10);
      if (Number.isNaN(n)) return;
      value = n;
    } else if (option.value === '') {
      return;
    } else {
      value = option.value;
    }

    if (option.id === 'processScripts' || option.id === 'removeEmptyElementsExcept') {
      value = value.split(/\s*,\s*/);
    }

    if (option.id === 'ignoreCustomFragments') {
      // Split by whitespace and convert each pattern to RegExp
      const patterns = value.split(/\s+/).filter(p => p.trim());
      value = patterns.map(pattern => {
        try {
          // Warn about potentially dangerous patterns (ReDoS risk)
          if (/\([^)]*[*+][^)]*\)[*+]/.test(pattern) || // Nested quantifiers like `(a+)+`
              /\*[^{]*\*/.test(pattern) || // Multiple unlimited quantifiers like `.*.*`
              /\+[^{]*\+/.test(pattern)) { // Multiple unlimited `+` quantifiers
            console.warn(`Potentially dangerous regex pattern detected: ${pattern}`);
            console.warn('This pattern may cause performance issues. Consider using bounded quantifiers like `{0,1000}`.');
          }

          // Pattern is already a string that should be used as regex
          return new RegExp(pattern);
        } catch (err) {
          console.warn(`Invalid regex pattern: ${pattern}`, err);
          return null;
        }
      }).filter(Boolean); // Remove any null values from invalid patterns
    }

    minifierOptions[option.id] = value;
  });

  return minifierOptions;
};

// URL State Management
const MAX_URL_LENGTH = 2000; // Conservative limit for URL hash

// Option migration map for backward compatibility
// When renaming options, add entries here to preserve old URLs
// Example: { 'oldOptionName': 'newOptionName' }
const OPTION_MIGRATIONS = {};

const encodeState = (input, options) => {
  const state = {
    i: input || '',
    o: {}
  };

  // Only store non-default options
  options.forEach((option) => {
    const defaultOption = defaultOptions.find(d => d.id === option.id);
    if (!defaultOption) return;

    if (option.type === 'checkbox') {
      if (option.checked !== defaultOption.checked) {
        state.o[option.id] = option.checked;
      }
    } else if (option.type === 'number') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    } else if (option.type === 'text') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    }
  });

  return LZString.compressToEncodedURIComponent(JSON.stringify(state));
};

const decodeState = (hash) => {
  try {
    const decompressed = LZString.decompressFromEncodedURIComponent(hash);
    if (!decompressed) return null;
    const state = JSON.parse(decompressed);

    // Apply option migrations for backward compatibility
    if (state.o) {
      const migratedOptions = {};
      for (const [key, value] of Object.entries(state.o)) {
        const newKey = OPTION_MIGRATIONS[key] || key;
        migratedOptions[newKey] = value;
      }
      state.o = migratedOptions;
    }

    return state;
  } catch {
    // Silently fail for invalid/corrupted URLs
    // console.warn('Failed to decode URL state');
    return null;
  }
};

const loadStateFromUrl = () => {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;

  return decodeState(hash);
};

const updateUrlWithState = (input, options) => {
  const encoded = encodeState(input, options);
  const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

  return {
    url,
    length: url.length,
    success: url.length <= MAX_URL_LENGTH
  };
};

// Register Alpine data
const minifierData = () => ({
  options: sillyClone(defaultOptions),
  input: '',
  output: '',
  stats: {
    result: '',
    text: ''
  },
  share: '',
  _shareTimeout: null,

  init() {
    // Load state from URL on page load
    const state = loadStateFromUrl();
    if (state) {
      this.input = state.i || '';

      // Apply saved options
      if (state.o) {
        this.options = this.options.map((option) => {
          if (option.id in state.o) {
            return {
              ...option,
              checked: option.type === 'checkbox' ? state.o[option.id] : option.checked,
              value: option.type !== 'checkbox' ? state.o[option.id] : option.value
            };
          }
          return option;
        });
      }

      if (this.input) {
        this.minify();
      }
    }
  },

  async minify() {
    this.stats = {
      result: '',
      text: ''
    };
    this.share = '';

    const options = getOptions(this.options);

    try {
      const data = await HTMLMinifier.minify(this.input, options);

      const diff = this.input.length - data.length;
      const savings = this.input.length ? (100 * diff / this.input.length).toFixed(2) : 0;

      this.output = data;
      this.stats.result = 'success';
      this.stats.text = `Original size: ${this.input.length}, minified size: ${data.length}, savings: ${diff} (${savings}%)`;
    } catch (err) {
      this.output = '';
      this.stats.result = 'failure';

      let errorText = err + '';

      // Check if error is a parse error and input contains template syntax
      if (errorText.includes('Parse error')) {
        const templatePatterns = [
          { regex: /\{%[\s\S]*?%\}/, name: 'Jinja/Django/Wagtail', pattern: '\\{%[\\s\\S]{0,1000}?%\\}' },
          { regex: /\{\{[\s\S]*?\}\}/, name: 'Handlebars/Vue/Angular/Mustache', pattern: '\\{\\{[\\s\\S]{0,500}?\\}\\}' },
          { regex: /<\?php[\s\S]*?\?>/, name: 'PHP', pattern: '<\\?php[\\s\\S]{0,5000}?\\?>' },
          { regex: /<%[\s\S]*?%>/, name: 'JSP/ASP', pattern: '<%[\\s\\S]{0,1000}?%>' }
        ];

        const detectedTemplates = templatePatterns.filter(t => t.regex.test(this.input));

        if (detectedTemplates.length > 0) {
          const suggestions = detectedTemplates.map(t => t.pattern).join(' ');
          errorText += `\n\nðŸ’¡ Tip: Detected ${detectedTemplates.map(t => t.name).join('/')} template syntax. Add this to the "Ignore custom fragments" field:\n${suggestions}`;
        }
      }

      this.stats.text = errorText;
      console.error(err);
    }
  },

  async shareUrl() {
    // Clear any existing timeout to prevent race conditions
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }

    this.share = '';

    const result = updateUrlWithState(this.input, this.options);

    if (result.success) {
      // Update URL in browser
      window.history.pushState(null, '', result.url);

      // Copy to clipboard
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        this.share = `âœ“ URL updated (${result.length} characters). Clipboard not supportedâ€”copy from address bar.`;
      } else {
        try {
          await navigator.clipboard.writeText(result.url);
          this.share = `âœ“ URL copied to clipboard (${result.length} characters)`;
        } catch {
          this.share = `âœ“ URL updated (${result.length} characters). Copy from address bar.`;
        }
      }

      // Clear message after 5 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 5000);
    } else {
      // Try without input (options only)
      const optionsOnly = updateUrlWithState('', this.options);

      if (optionsOnly.success) {
        window.history.pushState(null, '', optionsOnly.url);

        // Copy to clipboard
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          this.share = `âš  Code too large for URL (${result.length} chars). Sharing options only. Clipboard not supportedâ€”copy from address bar.`;
        } else {
          try {
            await navigator.clipboard.writeText(optionsOnly.url);
            this.share = `âš  Code too large for URL (${result.length} chars). Sharing options only. URL copied to clipboard.`;
          } catch {
            this.share = `âš  Code too large for URL (${result.length} chars). Sharing options only. Copy from address bar.`;
          }
        }
      } else {
        this.share = `âœ— Content too large to share via URL (${optionsOnly.length} characters, max ${MAX_URL_LENGTH})`;
      }

      // Clear message after 8 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 8000);
    }
  },

  selectAllOptions(yes = true) {
    this.options = this.options.map((option) => {
      if (option.type !== 'checkbox' || option.disabled) {
        return option;
      }

      return {
        ...option,
        checked: Boolean(yes)
      };
    });
  },

  applyPreset(presetName) {
    const preset = getPreset(presetName);
    if (!preset) {
      console.error(`Unknown preset: ${presetName}`);
      return;
    }

    // Apply preset to options
    this.options = this.options.map((option) => {
      if (option.type === 'checkbox' && option.id in preset) {
        return {
          ...option,
          checked: preset[option.id]
        };
      } else if (option.type !== 'checkbox' && option.id in preset) {
        return {
          ...option,
          value: preset[option.id]
        };
      }
      // For options not in preset, reset to default
      const defaultOption = defaultOptions.find(d => d.id === option.id);
      if (option.type === 'checkbox') {
        return {
          ...option,
          checked: defaultOption?.checked || false
        };
      } else {
        return {
          ...option,
          value: defaultOption?.value || ''
        };
      }
    });

    // Clear output and stats when applying preset
    this.output = '';
    this.stats = { result: '', text: '' };
    this.share = '';
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }
  },

  resetOptions() {
    // Reset each option to its default value (similar to `applyPreset`)
    this.options = this.options.map((option) => {
      const defaultOption = defaultOptions.find(d => d.id === option.id);
      if (!defaultOption) return option;

      if (option.type === 'checkbox') {
        return {
          ...option,
          checked: defaultOption.checked || false
        };
      } else {
        return {
          ...option,
          value: defaultOption.value || ''
        };
      }
    });

    this.output = '';
    this.stats = { result: '', text: '' };
    this.share = '';
    // Clear any pending share message timeout
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }
    // Clear URL hash
    window.history.pushState(null, '', window.location.pathname);
  }
});

const registerMinifier = () => window.Alpine.data('minifier', minifierData);
if (window.Alpine) {
  registerMinifier();
} else {
  document.addEventListener('alpine:init', registerMinifier, { once: true });
}

document.getElementById('minifier-version').innerText = `(v${pkg.version})`;