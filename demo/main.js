import HTMLMinifier from '../dist/htmlminifier.esm.bundle.js';
import pkg from '../package.json' with { type: 'json' };

const defaultOptions = [
  {
    id: 'caseSensitive',
    type: 'checkbox',
    label: 'Case-sensitive',
    helpText: 'Treat attributes in case-sensitive manner (useful for custom HTML elements)'
  },
  {
    id: 'collapseBooleanAttributes',
    type: 'checkbox',
    label: 'Collapse boolean attributes',
    helpText: 'Omit attribute values from boolean attributes',
    checked: true
  },
  {
    id: 'collapseInlineTagWhitespace',
    type: 'checkbox',
    label: 'Collapse inline tag whitespace',
    helpText: `Don’t leave any spaces between <code>display: inline;</code> elements when collapsing—use with <code>collapseWhitespace=true</code>`,
    unsafe: true
  },
  {
    id: 'collapseWhitespace',
    type: 'checkbox',
    label: 'Collapse whitespace',
    helpText: 'Collapse whitespace that contributes to text nodes in a document tree',
    checked: true
  },
  {
    id: 'conservativeCollapse',
    type: 'checkbox',
    label: 'Conservative collapse',
    helpText: `Always collapse to 1 space (never remove it entirely)—use with <code>collapseWhitespace=true</code>`
  },
  {
    id: 'decodeEntities',
    type: 'checkbox',
    label: 'Decode Entity Characters',
    helpText: 'Use direct Unicode characters whenever possible',
    checked: true
  },
  {
    id: 'html5',
    type: 'checkbox',
    label: 'HTML',
    helpText: 'Parse input according to the HTML specification',
    checked: true
  },
  {
    id: 'includeAutoGeneratedTags',
    type: 'checkbox',
    label: 'Include auto-generated tags',
    helpText: 'Insert elements generated by HTML parser'
  },
  {
    id: 'keepClosingSlash',
    type: 'checkbox',
    label: 'Keep closing slash',
    helpText: 'Keep the trailing slash on void elements'
  },
  {
    id: 'maxLineLength',
    type: 'number',
    label: 'Max line length',
    helpText: 'Specify a maximum line length; compressed output will be split by newlines at valid HTML split-points'
  },
  {
    id: 'minifyCSS',
    type: 'checkbox',
    label: 'Minify CSS',
    helpText: 'Minify CSS in <code>style</code> elements and <code>style</code> attributes (disabled in web version—Lightning CSS requires Node.js)',
    checked: false,
    disabled: true
  },
  {
    id: 'minifyJS',
    type: 'checkbox',
    label: 'Minify JavaScript',
    helpText: 'Minify JavaScript in <code>script</code> elements and event attributes (uses Terser)',
    checked: true
  },
  {
    id: 'minifyURLs',
    type: 'checkbox',
    label: 'Minify URLs',
    helpText: 'Minify URLs in various attributes (uses relateurl)'
  },
  {
    id: 'noNewlinesBeforeTagClose',
    type: 'checkbox',
    label: 'No newline before Tag Close',
    helpText: 'Never add a newline before a tag that closes an element'
  },
  {
    id: 'preserveLineBreaks',
    type: 'checkbox',
    label: 'Preserve line-breaks',
    helpText: `Always collapse to 1 line break (never remove it entirely) when whitespace between tags includes a line break—use with <code>collapseWhitespace=true</code>`
  },
  {
    id: 'preventAttributesEscaping',
    type: 'checkbox',
    label: 'Prevent attributes escaping',
    helpText: 'Prevents the escaping of the values of attributes',
    unsafe: true
  },
  {
    id: 'processConditionalComments',
    type: 'checkbox',
    label: 'Process conditional comments',
    helpText: 'Process contents of conditional comments through minifier',
    checked: true
  },
  {
    id: 'processScripts',
    type: 'text',
    label: 'Process scripts',
    helpText: 'Array of strings corresponding to types of <code>script</code> elements to process through minifier (e.g., <code>text/ng-template</code>, <code>text/x-handlebars-template</code>, etc.)',
    value: 'text/html'
  },
  {
    id: 'quoteCharacter',
    type: 'text',
    label: 'Quote character',
    helpText: 'Type of quote to use for attribute values (<code>\'</code> or <code>"</code>)',
  },
  {
    id: 'removeAttributeQuotes',
    type: 'checkbox',
    label: 'Remove attribute quotes',
    helpText: 'Remove quotes around attributes when possible',
    checked: true
  },
  {
    id: 'removeComments',
    type: 'checkbox',
    label: 'Remove comments',
    helpText: 'Strip HTML comments',
    checked: true
  },
  {
    id: 'removeEmptyAttributes',
    type: 'checkbox',
    label: 'Remove empty attributes',
    helpText: 'Remove all attributes with whitespace-only values',
    checked: true
  },
  {
    id: 'removeEmptyElements',
    type: 'checkbox',
    label: 'Remove empty elements',
    helpText: 'Remove all elements with empty contents',
    unsafe: true
  },
  {
    id: 'removeOptionalTags',
    type: 'checkbox',
    label: 'Remove optional tags',
    helpText: 'Remove optional tags',
    checked: true
  },
  {
    id: 'removeRedundantAttributes',
    type: 'checkbox',
    label: 'Remove redundant attributes',
    helpText: 'Remove attributes when value matches default',
    checked: true
  },
  {
    id: 'removeScriptTypeAttributes',
    type: 'checkbox',
    label: 'Remove script type attributes',
    helpText: `Remove <code>type="text/javascript"</code> from <code>script</code> elements; other <code>type</code> attribute values are left intact`,
    checked: true
  },
  {
    id: 'removeStyleLinkTypeAttributes',
    type: 'checkbox',
    label: 'Remove style link type attributes',
    helpText: `Remove <code>type="text/css"</code> from <code>style</code> and <code>link</code> elements; other <code>type</code> attribute values are left intact`,
    checked: true
  },
  {
    id: 'removeTagWhitespace',
    type: 'checkbox',
    label: 'Remove tag whitespace',
    helpText: `Remove space between attributes whenever possible; <em>note that this will result in invalid HTML</em>`,
    unsafe: true
  },
  {
    id: 'sortAttributes',
    type: 'checkbox',
    label: 'Sort attributes',
    helpText: 'Sort attributes by frequency',
    unsafe: true
  },
  {
    id: 'sortClassName',
    type: 'checkbox',
    label: 'Sort class name',
    helpText: 'Sort style classes by frequency',
    unsafe: true
  },
  {
    id: 'trimCustomFragments',
    type: 'checkbox',
    label: 'Trim whitespace around custom fragments',
    helpText: 'Trim whitespace around custom fragments (PHP, JSP/ASP tags)',
    checked: true
  },
  {
    id: 'useShortDoctype',
    type: 'checkbox',
    label: 'Use short doctype',
    helpText: 'Replaces the doctype with the short (HTML) doctype',
    checked: true
  }
];

const sillyClone = (o) => JSON.parse(JSON.stringify(o));

const getOptions = (options) => {
  const minifierOptions = {};

  options.forEach((option) => {
    let value = null;

    if (option.type === 'checkbox') {
      value = Boolean(option.checked);
    } else if (option.type === 'number') {
      const n = Number.parseInt(String(option.value), 10);
      if (Number.isNaN(n)) return;
      value = n;
    } else if (option.value === '') {
      return;
    } else {
      value = option.value;
    }

    if (option.id === 'processScripts') {
      value = value.split(/\s*,\s*/);
    }

    minifierOptions[option.id] = value;
  });

  return minifierOptions;
};

// URL State Management
const MAX_URL_LENGTH = 2000; // Conservative limit for URL hash

// Option migration map for backward compatibility
// When renaming options, add entries here to preserve old URLs
// Example: { 'oldOptionName': 'newOptionName' }
const OPTION_MIGRATIONS = {};

const encodeState = (input, options) => {
  const state = {
    i: input || '',
    o: {}
  };

  // Only store non-default options
  options.forEach((option) => {
    const defaultOption = defaultOptions.find(d => d.id === option.id);
    if (!defaultOption) return;

    if (option.type === 'checkbox') {
      if (option.checked !== defaultOption.checked) {
        state.o[option.id] = option.checked;
      }
    } else if (option.type === 'number') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    } else if (option.type === 'text') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    }
  });

  return LZString.compressToEncodedURIComponent(JSON.stringify(state));
};

const decodeState = (hash) => {
  try {
    const decompressed = LZString.decompressFromEncodedURIComponent(hash);
    if (!decompressed) return null;
    const state = JSON.parse(decompressed);

    // Apply option migrations for backward compatibility
    if (state.o) {
      const migratedOptions = {};
      for (const [key, value] of Object.entries(state.o)) {
        const newKey = OPTION_MIGRATIONS[key] || key;
        migratedOptions[newKey] = value;
      }
      state.o = migratedOptions;
    }

    return state;
  } catch (e) {
    console.error('Failed to decode URL state:', e);
    return null;
  }
};

const loadStateFromUrl = () => {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;

  return decodeState(hash);
};

const updateUrlWithState = (input, options) => {
  const encoded = encodeState(input, options);
  const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

  return {
    url,
    length: url.length,
    success: url.length <= MAX_URL_LENGTH
  };
};

// Register Alpine data
const minifierData = () => ({
  options: sillyClone(defaultOptions),
  input: '',
  output: '',
  stats: {
    result: '',
    text: ''
  },
  share: '',
  _shareTimeout: null,

  init() {
    // Load state from URL on page load
    const state = loadStateFromUrl();
    if (state) {
      this.input = state.i || '';

      // Apply saved options
      if (state.o) {
        this.options = this.options.map((option) => {
          if (Object.prototype.hasOwnProperty.call(state.o, option.id)) {
            return {
              ...option,
              checked: option.type === 'checkbox' ? state.o[option.id] : option.checked,
              value: option.type !== 'checkbox' ? state.o[option.id] : option.value
            };
          }
          return option;
        });
      }
    }
  },

  async minify() {
    this.stats = {
      result: '',
      text: ''
    };
    this.share = '';

    const options = getOptions(this.options);

    try {
      const data = await HTMLMinifier.minify(this.input, options);

      const diff = this.input.length - data.length;
      const savings = this.input.length ? (100 * diff / this.input.length).toFixed(2) : 0;

      this.output = data;
      this.stats.result = 'success';
      this.stats.text = `Original size: ${this.input.length}, minified size: ${data.length}, savings: ${diff} (${savings}%)`;
    } catch (err) {
      this.output = '';
      this.stats.result = 'failure';
      this.stats.text = err + '';
      console.error(err);
    }
  },

  async shareUrl() {
    // Clear any existing timeout to prevent race conditions
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }

    this.share = '';

    const result = updateUrlWithState(this.input, this.options);

    if (result.success) {
      // Update URL in browser
      window.history.pushState(null, '', result.url);

      // Copy to clipboard
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        this.share = `✓ URL updated (${result.length} characters). Clipboard not supported—copy from address bar.`;
      } else {
        try {
          await navigator.clipboard.writeText(result.url);
          this.share = `✓ URL copied to clipboard (${result.length} characters)`;
        } catch {
          this.share = `✓ URL updated (${result.length} characters). Copy from address bar.`;
        }
      }

      // Clear message after 5 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 5000);
    } else {
      // Try without input (options only)
      const optionsOnly = updateUrlWithState('', this.options);

      if (optionsOnly.success) {
        window.history.pushState(null, '', optionsOnly.url);

        // Copy to clipboard
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          this.share = `⚠ Code too large for URL (${result.length} chars). Sharing options only. Clipboard not supported—copy from address bar.`;
        } else {
          try {
            await navigator.clipboard.writeText(optionsOnly.url);
            this.share = `⚠ Code too large for URL (${result.length} chars). Sharing options only. URL copied to clipboard.`;
          } catch {
            this.share = `⚠ Code too large for URL (${result.length} chars). Sharing options only. Copy from address bar.`;
          }
        }
      } else {
        this.share = `✗ Content too large to share via URL (${result.length} characters, max ${MAX_URL_LENGTH})`;
      }

      // Clear message after 8 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 8000);
    }
  },

  selectAllOptions(yes = true) {
    this.options = this.options.map((option) => {
      if (option.type !== 'checkbox' || option.disabled) {
        return option;
      }

      return {
        ...option,
        checked: Boolean(yes)
      };
    });
  },

  resetOptions() {
    this.options = sillyClone(defaultOptions);
    this.output = '';
    this.stats = { result: '', text: '' };
    this.share = '';
    // Clear any pending share message timeout
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }
    // Clear URL hash
    window.history.pushState(null, '', window.location.pathname);
  }
});

const registerMinifier = () => window.Alpine.data('minifier', minifierData);
if (window.Alpine) {
  registerMinifier();
} else {
  document.addEventListener('alpine:init', registerMinifier, { once: true });
}

document.getElementById('minifier-version').innerText = `(v${pkg.version})`;