import HTMLMinifier, { getPreset } from '../dist/htmlminifier.esm.bundle.js';
import { optionDefinitions } from '../src/lib/option-definitions.js';
import pkg from '../package.json' with { type: 'json' };

// Escape HTML entities for safe rendering inside `<code>` elements
const escapeHtml = (str) => str
  .replace(/&/g, '&amp;')
  .replace(/</g, '&lt;')
  .replace(/>/g, '&gt;');

// Convert CLI-style descriptions to demo-style HTML
// - Backticks â†’ `<code>` elements (with HTML escaping)
// - `--kebab-case` â†’ `camelCase` (for option cross-references)
const toHtml = (desc) => desc
  .replace(/`--([a-z-]+)`/g, (_, kebab) => `<code>${kebab.replace(/-([a-z])/g, (__, c) => c.toUpperCase())}</code>`)
  .replace(/`([^`]+)`/g, (_, content) => `<code>${escapeHtml(content)}</code>`);

// Demo-specific UI configuration
const demoConfig = {
  // Input types and labels
  caseSensitive: {
    label: 'Case-sensitive'
  },
  collapseAttributeWhitespace: {
    label: 'Collapse attribute whitespace',
    checked: true
  },
  collapseBooleanAttributes: {
    label: 'Collapse boolean attributes',
    checked: true
  },
  collapseInlineTagWhitespace: {
    label: 'Collapse inline tag whitespace',
    unsafe: true
  },
  collapseWhitespace: {
    label: 'Collapse whitespace',
    checked: true
  },
  conservativeCollapse: {
    label: 'Conservative collapse'
  },
  customAttrAssign: {
    label: 'Custom attribute assign',
    inputType: 'text',
    helpText: 'Array of regexes that allow to support custom attribute assign expressions (e.g., <code>\\?=</code> for <code>flex?="{{mode}}"</code>)'
  },
  customAttrCollapse: {
    label: 'Custom attribute collapse',
    inputType: 'text'
  },
  decodeEntities: {
    label: 'Decode entity characters',
    checked: true
  },
  ignoreCustomComments: {
    label: 'Ignore custom comments',
    inputType: 'text',
    helpText: 'Array of regexes that allow to ignore matching comments (e.g., <code>^\\s*ko</code> for Knockout.js; defaults: <code>^!</code> and <code>^\\s*#</code>)'
  },
  ignoreCustomFragments: {
    label: 'Ignore custom fragments',
    inputType: 'text',
    helpText: 'Space-separated regex patterns for template syntax to ignoreâ€”<em>use bounded quantifiers</em> like <code>{0,1000}</code> to prevent performance issues (e.g., <code>\\{%[\\s\\S]{0,1000}?%\\}</code> for Jinja/Django, <code>\\{\\{[\\s\\S]{0,500}?\\}\\}</code> for Handlebars/Vue)'
  },
  includeAutoGeneratedTags: {
    label: 'Include auto-generated tags'
  },
  inlineCustomElements: {
    label: 'Inline custom elements',
    inputType: 'text'
  },
  keepClosingSlash: {
    label: 'Keep closing slash'
  },
  maxLineLength: {
    label: 'Max line length',
    inputType: 'number'
  },
  mergeScripts: {
    label: 'Merge scripts',
    checked: true
  },
  minifyCSS: {
    label: 'Minify CSS',
    checked: false,
    disabled: true,
    helpText: 'Minify CSS in <code>style</code> elements and attributes (disabled in web demoâ€”Lightning CSS requires Node.js)'
  },
  minifyJS: {
    label: 'Minify JavaScript',
    checked: true,
    helpText: 'Minify JavaScript in <code>script</code> elements and event attributes (uses Terser)'
  },
  minifySVG: {
    label: 'Minify SVG',
    checked: true
  },
  minifyURLs: {
    label: 'Minify URLs',
    checked: true
  },
  noNewlinesBeforeTagClose: {
    label: 'No newline before tag close'
  },
  partialMarkup: {
    label: 'Partial markup'
  },
  preserveLineBreaks: {
    label: 'Preserve line breaks'
  },
  preventAttributesEscaping: {
    label: 'Prevent attributes escaping',
    unsafe: true
  },
  processConditionalComments: {
    label: 'Process conditional comments',
    checked: true
  },
  processScripts: {
    label: 'Process scripts',
    inputType: 'text',
    value: 'text/html'
  },
  quoteCharacter: {
    label: 'Quote character',
    inputType: 'text'
  },
  removeAttributeQuotes: {
    label: 'Remove attribute quotes'
  },
  removeComments: {
    label: 'Remove comments',
    checked: true
  },
  removeEmptyAttributes: {
    label: 'Remove empty attributes',
    checked: true
  },
  removeEmptyElements: {
    label: 'Remove empty elements',
    unsafe: true
  },
  removeEmptyElementsExcept: {
    label: 'Remove empty elements except',
    inputType: 'text'
  },
  removeOptionalTags: {
    label: 'Remove optional tags',
    checked: true
  },
  removeRedundantAttributes: {
    label: 'Remove redundant attributes',
    checked: true
  },
  removeScriptTypeAttributes: {
    label: 'Remove script type attributes',
    checked: true
  },
  removeStyleLinkTypeAttributes: {
    label: 'Remove style link type attributes',
    checked: true
  },
  removeTagWhitespace: {
    label: 'Remove tag whitespace',
    unsafe: true
  },
  sortAttributes: {
    label: 'Sort attributes',
    unsafe: true
  },
  sortClassNames: {
    label: 'Sort class names',
    unsafe: true
  },
  trimCustomFragments: {
    label: 'Trim whitespace around custom fragments'
  },
  useShortDoctype: {
    label: 'Use short doctype',
    checked: true
  }
};

// Options to show in demo (subset of all options)
const demoOptionIds = Object.keys(demoConfig);

// Build defaultOptions from optionDefinitions + demoConfig
const defaultOptions = demoOptionIds.map(id => {
  const def = optionDefinitions[id];
  const cfg = demoConfig[id];
  const inputType = cfg.inputType || 'checkbox';
  return {
    id,
    type: inputType,
    label: cfg.label,
    helpText: cfg.helpText || toHtml(def.description),
    ...(inputType === 'checkbox' ? { checked: cfg.checked || false } : { value: cfg.value ?? '' }),
    ...(cfg.unsafe && { unsafe: true }),
    ...(cfg.disabled && { disabled: true })
  };
});

const sillyClone = (o) => JSON.parse(JSON.stringify(o));

const formatNumber = (num) => num.toLocaleString('en-US');

const getOptions = (options) => {
  const minifierOptions = {};

  options.forEach((option) => {
    let value = null;

    if (option.type === 'checkbox') {
      value = Boolean(option.checked);
    } else if (option.type === 'number') {
      const n = Number.parseInt(String(option.value), 10);
      if (Number.isNaN(n)) return;
      value = n;
    } else if (option.value === '') {
      return;
    } else {
      value = option.value;
    }

    if (option.id === 'processScripts' || option.id === 'removeEmptyElementsExcept' || option.id === 'inlineCustomElements') {
      value = value.split(/\s*,\s*/).map(s => s.trim()).filter(Boolean);
    }

    if (option.id === 'customAttrCollapse') {
      try {
        value = new RegExp(value);
      } catch (err) {
        console.warn(`Invalid regex pattern: ${value}`, err);
        return;
      }
    }

    if (option.id === 'ignoreCustomComments' || option.id === 'customAttrAssign' || option.id === 'ignoreCustomFragments') {
      // Split by whitespace and convert each pattern to RegExp
      const patterns = value.split(/\s+/).filter(p => p.trim());
      value = patterns.map(pattern => {
        try {
          // Warn about potentially dangerous patterns (ReDoS risk)
          if (/\([^)]*[*+][^)]*\)[*+]/.test(pattern) || // Nested quantifiers like `(a+)+`
              /\*[^{]*\*/.test(pattern) || // Multiple unlimited quantifiers like `.*.*`
              /\+[^{]*\+/.test(pattern)) { // Multiple unlimited `+` quantifiers
            console.warn(`Potentially dangerous regex pattern detected: ${pattern}`);
            console.warn('This pattern may cause performance issues. Consider using bounded quantifiers like `{0,1000}`.');
          }
          return new RegExp(pattern);
        } catch (err) {
          console.warn(`Invalid regex pattern: ${pattern}`, err);
          return null;
        }
      }).filter(Boolean);
    }

    minifierOptions[option.id] = value;
  });

  return minifierOptions;
};

// URL State Management
const MAX_URL_LENGTH = 2000; // Conservative limit for URL hash

// Option migration map for backward compatibility
// When renaming options, add entries here to preserve old URLs
// Example: `{ 'oldOptionName': 'newOptionName' }`
const OPTION_MIGRATIONS = {
  html5: null, // Removed in 5.0.0; discard from old URLs
  sortClassName: 'sortClassNames'
};

const encodeState = (input, options) => {
  const state = {
    i: input || '',
    o: {}
  };

  // Only store non-default options
  options.forEach((option) => {
    const defaultOption = defaultOptions.find(d => d.id === option.id);
    if (!defaultOption) return;

    if (option.type === 'checkbox') {
      if (Boolean(option.checked) !== Boolean(defaultOption.checked)) {
        state.o[option.id] = option.checked;
      }
    } else if (option.type === 'number') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    } else if (option.type === 'text') {
      if (option.value !== defaultOption.value) {
        state.o[option.id] = option.value;
      }
    }
  });

  return LZString.compressToEncodedURIComponent(JSON.stringify(state));
};

const decodeState = (hash) => {
  try {
    const decompressed = LZString.decompressFromEncodedURIComponent(hash);
    if (!decompressed) return null;
    const state = JSON.parse(decompressed);

    // Apply option migrations for backward compatibility
    if (state.o) {
      const migratedOptions = {};
      for (const [key, value] of Object.entries(state.o)) {
        if (key in OPTION_MIGRATIONS) {
          // `null` means the option was removed; skip it
          if (OPTION_MIGRATIONS[key]) {
            migratedOptions[OPTION_MIGRATIONS[key]] = value;
          }
        } else {
          migratedOptions[key] = value;
        }
      }
      state.o = migratedOptions;
    }

    return state;
  } catch {
    // Silently fail for invalid/corrupted URLs
    // console.warn('Failed to decode URL state');
    return null;
  }
};

const loadStateFromUrl = () => {
  const hash = window.location.hash.slice(1);
  if (!hash) return null;

  return decodeState(hash);
};

const updateUrlWithState = (input, options) => {
  const encoded = encodeState(input, options);
  const url = `${window.location.origin}${window.location.pathname}#${encoded}`;

  return {
    url,
    length: url.length,
    success: url.length <= MAX_URL_LENGTH
  };
};

// Register Alpine data
const minifierData = () => ({
  options: sillyClone(defaultOptions),
  input: '',
  output: '',
  stats: {
    result: '',
    text: ''
  },
  share: '',
  _shareTimeout: null,

  init() {
    // Load state from URL on page load
    const state = loadStateFromUrl();
    if (state) {
      this.input = state.i || '';

      // Apply saved options
      if (state.o) {
        this.options = this.options.map((option) => {
          if (option.id in state.o) {
            return {
              ...option,
              checked: option.type === 'checkbox' ? state.o[option.id] : option.checked,
              value: option.type !== 'checkbox' ? state.o[option.id] : option.value
            };
          }
          return option;
        });
      }

      if (this.input) {
        this.minify();
      }
    }
  },

  async minify() {
    this.stats = {
      result: '',
      text: ''
    };
    this.share = '';

    const options = getOptions(this.options);

    try {
      const data = await HTMLMinifier.minify(this.input, options);

      const diff = this.input.length - data.length;
      const savings = this.input.length ? (100 * diff / this.input.length).toFixed(2) : 0;

      this.output = data;
      this.stats.result = 'success';
      this.stats.text = `Original size: ${formatNumber(this.input.length)}, minified size: ${formatNumber(data.length)}, savings: ${formatNumber(diff)} (${savings}%)`;
    } catch (err) {
      this.output = '';
      this.stats.result = 'failure';

      let errorText = err + '';

      // Check if error is a parse error and input contains template syntax
      if (errorText.includes('Parse error')) {
        const templatePatterns = [
          { regex: /\{%[\s\S]*?%\}/, name: 'Jinja/Django/Wagtail', pattern: '\\{%[\\s\\S]{0,1000}?%\\}' },
          { regex: /\{\{[\s\S]*?\}\}/, name: 'Handlebars/Vue/Angular/Mustache', pattern: '\\{\\{[\\s\\S]{0,500}?\\}\\}' },
          { regex: /<\?php[\s\S]*?\?>/, name: 'PHP', pattern: '<\\?php[\\s\\S]{0,5000}?\\?>' },
          { regex: /<%[\s\S]*?%>/, name: 'JSP/ASP', pattern: '<%[\\s\\S]{0,1000}?%>' }
        ];

        const detectedTemplates = templatePatterns.filter(t => t.regex.test(this.input));

        if (detectedTemplates.length > 0) {
          const suggestions = detectedTemplates.map(t => t.pattern).join(' ');
          errorText += `\n\nðŸ’¡ Tip: Detected ${detectedTemplates.map(t => t.name).join('/')} template syntax. Add this to the â€œIgnore custom fragmentsâ€ field:\n${suggestions}`;
        }
      }

      this.stats.text = errorText;
      console.error(err);
    }
  },

  async shareUrl() {
    // Clear any existing timeout to prevent race conditions
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }

    this.share = '';

    const result = updateUrlWithState(this.input, this.options);

    if (result.success) {
      // Update URL in browser
      window.history.pushState(null, '', result.url);

      // Copy to clipboard
      if (!navigator.clipboard || !navigator.clipboard.writeText) {
        this.share = `âœ“ URL updated (${formatNumber(result.length)} characters)â€”clipboard not supported, copy from address bar`;
      } else {
        try {
          await navigator.clipboard.writeText(result.url);
          this.share = `âœ“ URL copied to clipboard (${formatNumber(result.length)} characters)`;
        } catch {
          this.share = `âœ“ URL updated (${formatNumber(result.length)} characters)â€”copy from address bar`;
        }
      }

      // Clear message after 5 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 5000);
    } else {
      // Try without input (options only)
      const optionsOnly = updateUrlWithState('', this.options);

      if (optionsOnly.success) {
        window.history.pushState(null, '', optionsOnly.url);

        // Copy to clipboard
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          this.share = `âš  Code too large for URL (${formatNumber(result.length)} chars), sharing options onlyâ€”clipboard not supported, copy from address bar`;
        } else {
          try {
            await navigator.clipboard.writeText(optionsOnly.url);
            this.share = `âš  Code too large for URL (${formatNumber(result.length)} chars), sharing options onlyâ€”URL copied to clipboard`;
          } catch {
            this.share = `âš  Code too large for URL (${formatNumber(result.length)} chars), sharing options onlyâ€”copy from address bar`;
          }
        }
      } else {
        this.share = `âœ— Content too large to share via URL (${formatNumber(optionsOnly.length)} characters, max ${formatNumber(MAX_URL_LENGTH)})`;
      }

      // Clear message after 8 seconds
      this._shareTimeout = setTimeout(() => {
        this.share = '';
        this._shareTimeout = null;
      }, 8000);
    }
  },

  selectAllOptions(yes = true) {
    this.options = this.options.map((option) => {
      if (option.type !== 'checkbox' || option.disabled) {
        return option;
      }

      return {
        ...option,
        checked: Boolean(yes)
      };
    });
  },

  applyPreset(presetName) {
    const preset = getPreset(presetName);
    if (!preset) {
      console.error(`Unknown preset: ${presetName}`);
      return;
    }

    // Apply preset to options
    this.options = this.options.map((option) => {
      if (option.type === 'checkbox' && option.id in preset) {
        return {
          ...option,
          checked: option.disabled ? false : preset[option.id]
        };
      } else if (option.type !== 'checkbox' && option.id in preset) {
        return {
          ...option,
          value: preset[option.id]
        };
      }
      // For options not in preset, uncheck checkboxes and reset other inputs
      if (option.type === 'checkbox') {
        return {
          ...option,
          checked: false
        };
      } else {
        const defaultOption = defaultOptions.find(d => d.id === option.id);
        return {
          ...option,
          value: defaultOption?.value || ''
        };
      }
    });

    // Clear output and stats when applying preset
    this.output = '';
    this.stats = { result: '', text: '' };
    this.share = '';
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }
  },

  resetOptions() {
    // Reset each option to its default value (similar to `applyPreset`)
    this.options = this.options.map((option) => {
      const defaultOption = defaultOptions.find(d => d.id === option.id);
      if (!defaultOption) return option;

      if (option.type === 'checkbox') {
        return {
          ...option,
          checked: Boolean(defaultOption.checked)
        };
      } else {
        return {
          ...option,
          value: defaultOption.value || ''
        };
      }
    });

    this.output = '';
    this.stats = { result: '', text: '' };
    this.share = '';
    // Clear any pending share message timeout
    if (this._shareTimeout) {
      clearTimeout(this._shareTimeout);
      this._shareTimeout = null;
    }
    // Clear URL hash
    window.history.pushState(null, '', window.location.pathname);
  }
});

const registerMinifier = () => window.Alpine.data('minifier', minifierData);
if (window.Alpine) {
  registerMinifier();
} else {
  document.addEventListener('alpine:init', registerMinifier, { once: true });
}

document.getElementById('minifier-version').innerText = `(v${pkg.version})`;